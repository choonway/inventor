<html>
<body>
<p>SoXt
<hr>
<dl>
<dt>NAME
<dd>SoXt -- routines for Inventor/Xt compatibility.

<dt>INHERITS FROM
<dd>SoXt

<dt>DESCRIPTION
<dd>The SoXt class initializes Inventor for use with the Xt toolkit and Motif. SoXt::init() must be called in order for Inventor to work properly with Xt. SoXt::mainLoop() must be called in order for extension device events to be passed to Inventor render areas. The other methods are convenience functions. Refer to the SoXtComponent man pages for examples on how this class should be used when using Inventor Xt components.

<dt>METHODS
<dl>
<dt>static Widget <b>init</b>(const char *appName, const char *className = &quot;Inventor&quot;)
<dd>This is called to initialize Inventor and Xt, and bind Inventor with Xt eventhandling so that Inventor sensors will work correctly. This returns the top level shell widget. This method will call SoDB::init(), SoNodeKit::init(),SoInteraction::init() and XtAppInitialize().

<dt>static void <b>init</b>(Widget topLevelWidget)
<dd>This alternate form of init allows the application to initialize Xt. The passed widget should be the top level shell widget returned from the Xtinitializiation. This method will call SoDB::init(), SoNodeKit::init(), SoInteraction::init() and XtAppInitialize().

<dt>static void <b>mainLoop</b>()
<dd>This retrieves and dispatches events (loops forever). Unlike Xt which ignores extension devices (i.e. any device besides mouse and keyboard), this mainloop will dispatch events from input extension devices like the spaceball. It calls SoXt::nextEvent() and SoXt::dispatchEvent() to do this. If only the mouse and keyboard devices are used, this is equivalent to calling XtAppMainLoop().

<dt>static void <b>nextEvent</b>(XtAppContext appContext, XEvent *event)
<dd>Get the nextEvent by calling XtAppNextEvent(). The appContext can be had by calling SoXt::getAppContext().

<dt>static Boolean <b>dispatchEvent</b>(XEvent *event)
<dd>Dispatch the passed event to a handler. Mouse and keyboard events are dispatched by calling XtDispatchEvent(). Events from input extension devices are dispatched by code implemented in this routine. This returns True if a handler was found, else it returns False.

<dt>static <b>XtAppContextgetAppContext</b>()
<dt>static Display * <b>getDisplay</b>()
<dt>static Widget <b>getTopLevelWidget</b>()
<dd>These return information based on the top level widget returned by or passed to init.

<dt>static void <b>show</b>(Widget widget)
<dt>static void <b>hide</b>(Widget widget)
<dd>Convenience routines to show and hide the passed widget. For a shell widget, this is equivalent to calling RealizeWidget() +XMapWindow() or XMapRaised() if window already exists (raise and deiconify). hide() will then call XUnrealizeWidget(). For a subwidget, those simply calls XtManageChild() andXtUnmanageChild().
<dt>static XmString <b>encodeString</b>(char *s)
<dt>static char * <b>decodeString</b>(XmString xs)
<dd>These are convenience routines for encoding a character string as anXmString, and decoding an XmString back to a character string. (XmString is a Motif string). The application is responsible for freeing up the memorypointed to by these return values. Use XmStringFree() to free an XmString, and free() to free a character pointer.

<dt>static void <b>setWidgetSize</b>(Widget w, const SbVec2s &size)
<dt>static SbVec2s <b>getWidgetSize</b>(Widget w)
<dd>Convenience routines to set/get the size of the given widget. Those are equivalent to calling XtSetValues() and XtGetValues() on XtNheight and XtNwidth widget resources.

<dt>static Widget <b>getShellWidget</b>(Widget w)
<dd>Convenience routine which will return the ShellWidget containing the
given widget. The widget tree is traversed up until a shell widget is found using XtIsShell().

<dt>static void <b>createSimpleErrorDialog</b>(Widget widget, char *dialogTitle,char *errorStr1, char *errorStr2 = NULL)
<dd>Convenience routine which brings a simple motif error dialog boxdisplaying the given error string(s) and window title. The OK button, which destroys the dialog, is the only button displayed. The widget argument isused to create and center the dialog ( using XmCreateErrorDialog()).

<dt>static void <b>getPopupArgs</b>(Display *d, int scr, ArgList args, int *n)
<dd>Convenience routine which gets visual args for the popup planes. These args can then be passed in to XmCreatePulldownMenu() orXmCreatePopupMenu() to create menus in the popup planes. addColormapToShell() has to be called on the main popup window so setthe proper color map.

<dt>static void <b>addColormapToShell</b>(Widget widget, Widget shell)
<dd>Convenience routine to append the given widget colormap onto the supplied shell widget. This will not replace the existing installed colormaps(or list of windows), but instead append the new colormap to the existing list using XGetWMColormapWindows() andXSetWMColormapWindows().
</dl>

<dt>INCLUDE FILE
<dd>#include &lt;Inventor/Xt/SoXt.h&gt;

<dt>SEE ALSO
<dd><a href="soxtcomponent.html">SoXtComponent</a>
</dl>
</body>
</html>
